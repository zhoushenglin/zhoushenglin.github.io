<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Fun | Fun</title><meta name="description" content="复制粘贴工程师专用工具      .textarea-inherit {         width: 100%;         overflow: auto;         word-break: break-all; &#x2F;&#x2F;解决兼容问题     }     PS GPIO操作      #include &quot;platform.h&quot; #include &quot;xgpiops.h&quot; #define"><meta name="author" content="zhoushenglin"><meta name="copyright" content="zhoushenglin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.orangetech.fun/xilinx/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="website"><meta property="og:title" content="Fun"><meta property="og:url" content="http://www.orangetech.fun/xilinx/"><meta property="og:site_name" content="Fun"><meta property="og:description" content="复制粘贴工程师专用工具      .textarea-inherit {         width: 100%;         overflow: auto;         word-break: break-all; &#x2F;&#x2F;解决兼容问题     }     PS GPIO操作      #include &quot;platform.h&quot; #include &quot;xgpiops.h&quot; #define"><meta property="og:image" content="https://i.loli.net/2020/07/24/RMB739FgQeTSnhk.jpg"><meta property="article:published_time" content="2022-09-06T06:25:20.654Z"><meta property="article:modified_time" content="2022-09-06T06:25:20.654Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: false,
  postUpdate: '2022-09-06 14:25:20'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/text_tool/"><i class="fa-fw fas fa-archive"></i><span> 文本处理工具</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 代码生成器</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bes_code_gen/"><i class="fa-fw fas fa-link"></i><span> bes</span></a></li><li><a class="site-page" href="/arduino_code/"><i class="fa-fw fas fa-link"></i><span> Arduino</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fas fa-link"></i><span> python</span></a></li><li><a class="site-page" href="/freertos/"><i class="fa-fw fas fa-link"></i><span> freertos</span></a></li><li><a class="site-page" href="/zklx_code/"><i class="fa-fw fas fa-link"></i><span> zklx</span></a></li><li><a class="site-page" href="/c_/"><i class="fa-fw fas fa-link"></i><span> C#</span></a></li><li><a class="site-page" href="/xilinx/"><i class="fa-fw fas fa-link"></i><span> xilinx</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-archive"></i><span> 3D打印实用工具</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/findme/"><i class="fa-fw fas fa-archive"></i><span> 找到我</span></a></div></div></div></div><div id="body-wrap"><header class="not-index-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/07/24/iCTeM1xv4IEPSAX.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Fun</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/text_tool/"><i class="fa-fw fas fa-archive"></i><span> 文本处理工具</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 代码生成器</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bes_code_gen/"><i class="fa-fw fas fa-link"></i><span> bes</span></a></li><li><a class="site-page" href="/arduino_code/"><i class="fa-fw fas fa-link"></i><span> Arduino</span></a></li><li><a class="site-page" href="/python/"><i class="fa-fw fas fa-link"></i><span> python</span></a></li><li><a class="site-page" href="/freertos/"><i class="fa-fw fas fa-link"></i><span> freertos</span></a></li><li><a class="site-page" href="/zklx_code/"><i class="fa-fw fas fa-link"></i><span> zklx</span></a></li><li><a class="site-page" href="/c_/"><i class="fa-fw fas fa-link"></i><span> C#</span></a></li><li><a class="site-page" href="/xilinx/"><i class="fa-fw fas fa-link"></i><span> xilinx</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-archive"></i><span> 3D打印实用工具</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/findme/"><i class="fa-fw fas fa-archive"></i><span> 找到我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="page_site-info"><h1 id="site_title">Fun</h1></div></header><main class="layout_page" id="content-inner"><div id="page"><div id="article-container"><!DOCTYPE html>
<html>
<body>
<h1>复制粘贴工程师专用工具</h1>
<p>

</p>

<style>
.textarea-inherit {
        width: 100%;
        overflow: auto;
        word-break: break-all; //解决兼容问题
    }


</style>
<p>
PS GPIO操作
</p>   
<textarea class="textarea-inherit" rows ="45";>
#include "platform.h"
#include "xgpiops.h"
#define GPIO_DEVICE_ID		XPAR_XGPIOPS_0_DEVICE_ID
#define PS_KEY_MIO      26
#define PS_LED_MIO      40
#define GPIO_INPUT      0
#define GPIO_OUTPUT     1

XGpioPs xx_ps_Gpio;
void xx_ps_gpio_init()
{
	XGpioPs_Config *ConfigPtr;
	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
	
	XGpioPs_CfgInitialize(&xx_ps_Gpio, ConfigPtr,ConfigPtr->BaseAddr);

	XGpioPs_SetDirectionPin(&xx_ps_Gpio, PS_LED_MIO, 1);//set dir 
	XGpioPs_SetOutputEnablePin(&xx_ps_Gpio, PS_LED_MIO, 1);//enable output

}
void xx_ps_gpio_write(int val)
{

	XGpioPs_SetDirectionPin(&xx_ps_Gpio, PS_LED_MIO, 1);//set dir 
	XGpioPs_SetOutputEnablePin(&xx_ps_Gpio, PS_LED_MIO, 1);//enable output

	if(val)
	{
	XGpioPs_WritePin(&xx_ps_Gpio, PS_LED_MIO, 0x0);
	}
	else
		{
		XGpioPs_WritePin(&xx_ps_Gpio, PS_LED_MIO, 0x1);
	}

}
int xx_ps_gpio_read()
{
	XGpioPs_SetDirectionPin(&xx_ps_Gpio, PS_KEY_MIO, GPIO_INPUT);//set dir 
	

	return XGpioPs_ReadPin(&xx_ps_Gpio, PS_KEY_MIO);

}
</textarea>

<p>
PL GPIO操作
</p> 
<textarea class="textarea-inherit" rows ="48";>



		
</textarea>


<p>
写死设备号直接写寄存器点灯
</p> 
<textarea class="textarea-inherit" rows ="35";>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/ide.h>
#include <linux/types.h>

/* 驱动名称 */
#define DEVICE_NAME "gpio_leds"
/* 驱动主设备号 */
#define GPIO_LED_MAJOR 200

/* gpio 寄存器虚拟地址 */
static unsigned long gpio_add_minor;
/* gpio 寄存器物理基地址 */
#define GPIO_BASE 0xFF0A0000
/* gpio 寄存器所占空间大小 */
#define GPIO_SIZE 0x1000
/* gpio 方向寄存器 */
#define GPIO_DIRM_1 (unsigned int *)(0x0000000000000244 + (unsigned long)gpio_add_minor)
/* gpio 使能寄存器 */
#define GPIO_OEN_1 (unsigned int *)(0x0000000000000248 + (unsigned long)gpio_add_minor)
/* gpio 控制寄存器 */
#define GPIO_DATA_1 (unsigned int *)(0x0000000000000044 + (unsigned long)gpio_add_minor)

/* open 函数实现, 对应到 Linux 系统调用函数的 open 函数 */
static int gpio_leds_open(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module open\n");

	return 0;
}


/* write 函数实现, 对应到 Linux 系统调用函数的 write 函数 */
static ssize_t gpio_leds_write(struct file *file_p, const char __user *buf, size_t len, loff_t *
		_t_p)
{
	int rst;
	char writeBuf[5] = {0};

	printk("gpio_test module write\n");

	rst = copy_from_user(writeBuf, buf, len);
	if(0 != rst)
	{
		return -1;
	}

	if(1 != len)
	{
		printk("gpio_test len err\n");
		return -2;
	}
	if(1 == writeBuf[0])
	{
		*GPIO_DATA_1 |= 0x00004000;
		printk("gpio_test ON *GPIO_DATA_1 = 0x%X\r\n", *GPIO_DATA_1);
	}
	else if(0 == writeBuf[0])
	{
		*GPIO_DATA_1 &= 0xFFFFBFFF;
		printk("gpio_test OFF *GPIO_DATA_1 = 0x%X\r\n", *GPIO_DATA_1);
	}
	else
	{
		printk("gpio_test para err\n");
		return -3;
	}

	return 0;
}

/* release 函数实现, 对应到 Linux 系统调用函数的 close 函数 */
static int gpio_leds_release(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module release\n");
	return 0;
}

/* file_operations 结构体声明, 是上面 open、write 实现函数与系统调用函数对应的关键 */
static struct file_operations gpio_leds_fops = {
	.owner = THIS_MODULE,
	.open = gpio_leds_open,
	.write = gpio_leds_write,
	.release = gpio_leds_release,
};

/* 模块加载时会调用的函数 */
static int __init gpio_led_init(void)
{
	int ret;

	/* 通过模块主设备号、名称、模块带有的功能函数(及 file_operations 结构体)来注册模块 */
	ret = register_chrdev(GPIO_LED_MAJOR, DEVICE_NAME, &gpio_leds_fops);
	if (ret < 0)
	{
		printk("gpio_led_dev_init_ng\n");
		return ret;
	}
	else
	{
		/* 注册成功 */
		printk("gpio_led_dev_init_ok\n");
		/* 把需要修改的物理地址映射到虚拟地址 */
		gpio_add_minor = ioremap_wc(GPIO_BASE, GPIO_SIZE);
		printk("gpio_add_minor = 0x%lX\n", gpio_add_minor);
		printk("GPIO_DIRM_1 = 0x%lX\n", (unsigned long)GPIO_DIRM_1);
		printk("GPIO_OEN_1 = 0x%lX\n", (unsigned long)GPIO_OEN_1);

		/* MIO_0 设置成输出 */
		*GPIO_DIRM_1 |= 0x00004000;
		/* MIO_0 使能 */
		*GPIO_OEN_1 |= 0x00004000;

		printk("*GPIO_DIRM_1 = 0x%X\n", *GPIO_DIRM_1);
		printk("*GPIO_OEN_1 = 0x%X\n", *GPIO_OEN_1);
	}
	return 0;
}

/* 卸载模块 */
static void __exit gpio_led_exit(void)
{
	*GPIO_OEN_1 &= 0xFFFFBFFF;

	/* 释放对虚拟地址的占用 */
	iounmap(gpio_add_minor);
	/* 注销模块, 释放模块对这个设备号和名称的占用 */
	unregister_chrdev(GPIO_LED_MAJOR, DEVICE_NAME);

	printk("gpio_led_dev_exit_ok\n");
}

/* 标记加载、卸载函数 */
module_init(gpio_led_init);
module_exit(gpio_led_exit);

/* 驱动描述信息 */
MODULE_AUTHOR("Alinx");
MODULE_ALIAS("gpio_led");
MODULE_DESCRIPTION("GPIO LED driver");
MODULE_VERSION("v1.0");
MODULE_LICENSE("GPL");


</textarea>

<p>
自动分配设备号点灯
</p> 
<textarea class="textarea-inherit" rows ="28";>

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/ide.h>
#include <linux/types.h>
#include <linux/errno.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <asm/uaccess.h>

/* 设备节点名称 */
#define DEVICE_NAME "gpio_leds"
/* 设备号个数 */
#define DEVID_COUNT 1
/* 驱动个数 */
#define DRIVE_COUNT 1
/* 主设备号 */
#define MAJOR
/* 次设备号 */
#define MINOR 0

/* gpio 寄存器虚拟地址 */
static unsigned long gpio_add_minor;
/* gpio 寄存器物理基地址 */
#define GPIO_BASE 0xFF0A0000
/* gpio 寄存器所占空间大小 */
#define GPIO_SIZE 0x1000
/* gpio 方向寄存器 */
#define GPIO_DIRM_1 (unsigned int *)(0x0000000000000244 + (unsigned long)gpio_add_minor)
/* gpio 使能寄存器 */
#define GPIO_OEN_1 (unsigned int *)(0x0000000000000248 + (unsigned long)gpio_add_minor)
/* gpio 控制寄存器 */
#define GPIO_DATA_1 (unsigned int *)(0x0000000000000044 + (unsigned long)gpio_add_minor)

/* 把驱动代码中会用到的数据打包进设备结构体 */
struct alinx_char_dev{
	dev_t devid; //设备号
	struct cdev cdev; //字符设备
	struct class *class; //类
	struct device *device; //设备节点
};
/* 声明设备结构体 */
static struct alinx_char_dev alinx_char = {
	.cdev = {
		.owner = THIS_MODULE,
	},
};

/* open 函数实现, 对应到 Linux 系统调用函数的 open 函数 */
static int gpio_leds_open(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module open\n");

	return 0;
}


/* write 函数实现, 对应到 Linux 系统调用函数的 write 函数 */
static ssize_t gpio_leds_write(struct file *file_p, const char __user *buf, size_t len, loff_t *
		f_t_p)
{
	int rst;
	char writeBuf[5] = {0};

	printk("gpio_test module write\n");

	rst = copy_from_user(writeBuf, buf, len);
	if(0 != rst)
	{
		return -1;
	}

	if(1 != len)
	{
		printk("gpio_test len err\n");
		return -2;
	}
	if(1 == writeBuf[0])
	{
		*GPIO_DATA_1 |= 0x00004000;
		printk("gpio_test ON\n");
	}
	else if(0 == writeBuf[0])
	{
		*GPIO_DATA_1 &= 0xFFFFBFFF;
		printk("gpio_test OFF\n");
	}
	else
	{
		printk("gpio_test para err\n");
		return -3;
	}

	return 0;
}

/* release 函数实现, 对应到 Linux 系统调用函数的 close 函数 */
static int gpio_leds_release(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module release\n");
	return 0;
}

/* file_operations 结构体声明, 是上面 open、write 实现函数与系统调用函数对应的关键 */
static struct file_operations ax_char_fops = {
	.owner = THIS_MODULE,
	.open = gpio_leds_open,
	.write = gpio_leds_write,
	.release = gpio_leds_release,
};

/* 模块加载时会调用的函数 */
static int __init gpio_led_init(void)
{
	/* 注册设备号 */
	alloc_chrdev_region(&alinx_char.devid, MINOR, DEVID_COUNT, DEVICE_NAME);

	/* 初始化字符设备结构体 */
	cdev_init(&alinx_char.cdev, &ax_char_fops);
	/* 注册字符设备 */
	cdev_add(&alinx_char.cdev, alinx_char.devid, DRIVE_COUNT);

	/* 创建类 */
	alinx_char.class = class_create(THIS_MODULE, DEVICE_NAME);
	if(IS_ERR(alinx_char.class))
	{
		return PTR_ERR(alinx_char.class);
	}

	/* 创建设备节点 */
	alinx_char.device = device_create(alinx_char.class, NULL, alinx_char.devid, NULL, DEVICE_NAME);
	if (IS_ERR(alinx_char.device))
	{
		return PTR_ERR(alinx_char.device);
	}

	/* 把需要修改的物理地址映射到虚拟地址 */
	gpio_add_minor = ioremap_wc(GPIO_BASE, GPIO_SIZE);

	/* MIO_0 设置成输出 */
	*GPIO_DIRM_1 |= 0x00004000;
	/* MIO_0 使能 */
	*GPIO_OEN_1 |= 0x00004000;

	return 0;
}

/* 卸载模块 */
static void __exit gpio_led_exit(void)
{
	/* 释放对虚拟地址的占用 */
	iounmap(gpio_add_minor);

	/* 注销字符设备 */
	cdev_del(&alinx_char.cdev);

	/* 注销设备号 */
	unregister_chrdev_region(alinx_char.devid, DEVID_COUNT);

	/* 删除设备节点 */
	device_destroy(alinx_char.class, alinx_char.devid);

	/* 删除类 */
	class_destroy(alinx_char.class);

	printk("gpio_led_dev_exit_ok\n");
}

/* 标记加载、卸载函数 */
module_init(gpio_led_init);
module_exit(gpio_led_exit);

/* 驱动描述信息 */
MODULE_AUTHOR("Alinx");
MODULE_ALIAS("gpio_led");
MODULE_DESCRIPTION("NEW GPIO LED driver");
MODULE_VERSION("v1.0");
MODULE_LICENSE("GPL");
MODULE_LICENSE("GPL");


</textarea>

<p>
设备树传参(GPIO寄存器地址)点灯
</p> 
<textarea class="textarea-inherit" rows ="56";>

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/ide.h>
#include <linux/types.h>
#include <linux/errno.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <asm/uaccess.h>
#include <linux/of.h>

/* 设备节点名称 */
#define DEVICE_NAME "gpio_leds"
/* 设备号个数 */
#define DEVID_COUNT 1
/* 驱动个数 */
#define DRIVE_COUNT 1
/* 主设备号 */
#define MAJOR
/* 次设备号 */
#define MINOR 0
#if 0
/* gpio 寄存器虚拟地址 */
static unsigned long gpio_add_minor;
/* gpio 寄存器物理基地址 */
#define GPIO_BASE 0xFF0A0000
/* gpio 寄存器所占空间大小 */
#define GPIO_SIZE 0x1000

/* gpio 方向寄存器 */
#define GPIO_DIRM_1 (unsigned int *)(0x0000000000000244 + (unsigned long)gpio_add_minor)
/* gpio 使能寄存器 */
#define GPIO_OEN_1 (unsigned int *)(0x0000000000000248 + (unsigned long)gpio_add_minor)
/* gpio 控制寄存器 */
#define GPIO_DATA_1 (unsigned int *)(0x0000000000000044 + (unsigned long)gpio_add_minor)
#endif

static u32 *GPIO_DIRM_1;
static u32 *GPIO_OEN_1;
static u32 *GPIO_DATA_1;
/* 把驱动代码中会用到的数据打包进设备结构体 */
struct alinx_char_dev{
	dev_t devid; //设备号
	struct cdev cdev; //字符设备
	struct class *class; //类
	struct device *device; //设备节点
	struct device_node *nd; //设备树的设备节点
};
/* 声明设备结构体 */
static struct alinx_char_dev alinx_char = {
	.cdev = {
		.owner = THIS_MODULE,
	},
};

/* open 函数实现, 对应到 Linux 系统调用函数的 open 函数 */
static int gpio_leds_open(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module open\n");

	return 0;
}


/* write 函数实现, 对应到 Linux 系统调用函数的 write 函数 */
static ssize_t gpio_leds_write(struct file *file_p, const char __user *buf, size_t len, loff_t *
		f_t_p)
{
	int rst;
	char writeBuf[5] = {0};

	printk("gpio_test module write\n");

	rst = copy_from_user(writeBuf, buf, len);
	if(0 != rst)
	{
		return -1;
	}

	if(1 != len)
	{
		printk("gpio_test len err\n");
		return -2;
	}
	if(1 == writeBuf[0])
	{
		*GPIO_DATA_1 |= 0x00004000;
		printk("gpio_test ON\n");
	}
	else if(0 == writeBuf[0])
	{
		*GPIO_DATA_1 &= 0xFFFFBFFF;
		printk("gpio_test OFF\n");
	}
	else
	{
		printk("gpio_test para err\n");
		return -3;
	}

	return 0;
}

/* release 函数实现, 对应到 Linux 系统调用函数的 close 函数 */
static int gpio_leds_release(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module release\n");
	return 0;
}

/* file_operations 结构体声明, 是上面 open、write 实现函数与系统调用函数对应的关键 */
static struct file_operations ax_char_fops = {
	.owner = THIS_MODULE,
	.open = gpio_leds_open,
	.write = gpio_leds_write,
	.release = gpio_leds_release,
};

/* 模块加载时会调用的函数 */
static int __init gpio_led_init(void)
{
/* 用于接受返回值 */
u32 ret = 0;
/* 存放 reg 数据的数组 */
u32 reg_data[10];
/* 通过节点名称获取节点 */
alinx_char.nd = of_find_node_by_name(NULL, "alinxled");
/* 4、获取 reg 属性内容 */
ret = of_property_read_u32_array(alinx_char.nd, "reg", reg_data, 6);
if(ret < 0)
 {
printk("get reg failed!\r\n");
 return -1;
}
 else
 {
 /* do nothing */
 }
 printk("reg_data[0]=%x",reg_data[0]);
 printk("reg_data[1]=%x",reg_data[1]);
 printk("reg_data[2]=%x",reg_data[2]);
 printk("reg_data[3]=%x",reg_data[3]);
 printk("reg_data[4]=%x",reg_data[4]);
 printk("reg_data[5]=%x",reg_data[5]);
 
 GPIO_DIRM_1 = ioremap_wc(reg_data[0], reg_data[1]);
 GPIO_OEN_1 = ioremap_wc(reg_data[2], reg_data[3]);
 GPIO_DATA_1 = ioremap_wc(reg_data[4], reg_data[5]);

printk("GPIO_DIRM_1=%x",GPIO_DIRM_1);
printk("GPIO_OEN_1=%x",GPIO_OEN_1);
printk("GPIO_DATA_1=%x",GPIO_DATA_1);

	/* 注册设备号 */
	alloc_chrdev_region(&alinx_char.devid, MINOR, DEVID_COUNT, DEVICE_NAME);

	/* 初始化字符设备结构体 */
	cdev_init(&alinx_char.cdev, &ax_char_fops);
	/* 注册字符设备 */
	cdev_add(&alinx_char.cdev, alinx_char.devid, DRIVE_COUNT);

	/* 创建类 */
	alinx_char.class = class_create(THIS_MODULE, DEVICE_NAME);
	if(IS_ERR(alinx_char.class))
	{
		return PTR_ERR(alinx_char.class);
	}

	/* 创建设备节点 */
	alinx_char.device = device_create(alinx_char.class, NULL, alinx_char.devid, NULL, DEVICE_NAME);
	if (IS_ERR(alinx_char.device))
	{
		return PTR_ERR(alinx_char.device);
	}

	
	/* MIO_0 设置成输出 */
	*GPIO_DIRM_1 |= 0x00004000;
	/* MIO_0 使能 */
	*GPIO_OEN_1 |= 0x00004000;

	return 0;
}

/* 卸载模块 */
static void __exit gpio_led_exit(void)
{
	

	/* 注销字符设备 */
	cdev_del(&alinx_char.cdev);

	/* 注销设备号 */
	unregister_chrdev_region(alinx_char.devid, DEVID_COUNT);

	/* 删除设备节点 */
	device_destroy(alinx_char.class, alinx_char.devid);

	/* 删除类 */
	class_destroy(alinx_char.class);

/* 释放对虚拟地址的占用 */
iounmap(GPIO_DIRM_1);
 iounmap(GPIO_OEN_1);
 iounmap(GPIO_DATA_1);

	printk("gpio_led_dev_exit_ok\n");
}

/* 标记加载、卸载函数 */
module_init(gpio_led_init);
module_exit(gpio_led_exit);

/* 驱动描述信息 */
MODULE_AUTHOR("Alinx");
MODULE_ALIAS("gpio_led");
MODULE_DESCRIPTION("DEVICE TREE LED driver");
MODULE_VERSION("v1.0");
MODULE_LICENSE("GPL");
MODULE_LICENSE("GPL");


</textarea>

<p>
pin control 点灯
</p> 
<textarea class="textarea-inherit" rows ="25";>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/ide.h>
#include <linux/types.h>
#include <linux/errno.h>
#include <linux/cdev.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <asm/uaccess.h>
#include <asm/io.h>

/* 设备节点名称 */
#define DEVICE_NAME "gpio_leds"
/* 设备号个数 */
#define DEVID_COUNT 1
/* 驱动个数 */
#define DRIVE_COUNT 1
/* 主设备号 */
#define MAJOR1
/* 次设备号 */
#define MINOR1 0
/* LED 点亮时输入的值 */
#define ALINX_LED_ON 1
/* LED 熄灭时输入的值 */
#define ALINX_LED_OFF 0


/* 把驱动代码中会用到的数据打包进设备结构体 */
struct alinx_char_dev{
	dev_t devid; //设备号
	struct cdev cdev; //字符设备
	struct class *class; //类
	struct device *device; //设备
	struct device_node *nd; //设备树的设备节点
	int alinx_led_gpio; //gpio 号
};
/* 声明设备结构体 */
static struct alinx_char_dev alinx_char = {
	.cdev = {
		.owner = THIS_MODULE,
	},
};

/* open 函数实现, 对应到 Linux 系统调用函数的 open 函数 */
static int gpio_leds_open(struct inode *inode_p, struct file *file_p)
{
	/* 设置私有数据 */
	file_p->private_data = &alinx_char;
	printk("gpio_test module open\n");
	return 0;
}


/* write 函数实现, 对应到 Linux 系统调用函数的 write 函数 */
static ssize_t gpio_leds_write(struct file *file_p, const char __user *buf, size_t len, loff_t *loff_t_p)
{
	int retvalue;
	unsigned char databuf[1];
	/* 获取私有数据 */
	struct alinx_char_dev *dev = file_p->private_data;

	retvalue = copy_from_user(databuf, buf, len);
	if(retvalue < 0)
	{
		printk("alinx led write failed\r\n");
		return -EFAULT;
	}

	if(databuf[0] == ALINX_LED_ON)
	{
		gpio_set_value(dev->alinx_led_gpio, !!1);
	}
	else if(databuf[0] == ALINX_LED_OFF)
	{
		gpio_set_value(dev->alinx_led_gpio, !!0);
	}
	else
	{
		printk("gpio_test para err\n");
	}

	return 0;
}

/* release 函数实现, 对应到 Linux 系统调用函数的 close 函数 */
static int gpio_leds_release(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module release\n");
	return 0;
}

/* file_operations 结构体声明, 是上面 open、write 实现函数与系统调用函数对应的关
   键 */
static struct file_operations ax_char_fops = {
	.owner = THIS_MODULE,
	.open = gpio_leds_open,
	.write = gpio_leds_write,
	.release = gpio_leds_release,
};

/* 模块加载时会调用的函数 */
static int __init gpio_led_init(void)
{
	/* 用于接受返回值 */
	u32 ret = 0;

	/* 获取设备节点 */
	alinx_char.nd = of_find_node_by_path("/alinxled");
	if(alinx_char.nd == NULL)
	{
		printk("alinx_char node not find\r\n");
		return -EINVAL;
	}
	else
	{
		printk("alinx_char node find\r\n");
	}

	/* 获取节点中 gpio 标号 */
	alinx_char.alinx_led_gpio = of_get_named_gpio(alinx_char.nd, "alinxled-gpios", 0);
	printk("alinx_char.alinx_led_gpio = %d",alinx_char.alinx_led_gpio);
	
	if(alinx_char.alinx_led_gpio < 0)
	{
		printk("can not get alinxled-gpios");
		return -EINVAL;
	}
	printk("alinxled-gpio num = %d\r\n", alinx_char.alinx_led_gpio);

	/* 申请 gpio 标号对应的引脚 */
	ret = gpio_request(alinx_char.alinx_led_gpio, "alinxled-pin");//where is this name?
	if(ret != 0)
	{
		printk("can not request gpio\r\n");
	}

	/* 把这个 io 设置为输出 */
	ret = gpio_direction_output(alinx_char.alinx_led_gpio, 1);
	if(ret < 0)
	{
		printk("can not set gpio\r\n");
	}

	/* 注册设备号 */
	alloc_chrdev_region(&alinx_char.devid, MINOR1, DEVID_COUNT, DEVICE_NAME);

	/* 初始化字符设备结构体 */
	cdev_init(&alinx_char.cdev, &ax_char_fops);

	/* 注册字符设备 */
	cdev_add(&alinx_char.cdev, alinx_char.devid, DRIVE_COUNT);

	/* 创建类 */
	alinx_char.class = class_create(THIS_MODULE, DEVICE_NAME);
	if(IS_ERR(alinx_char.class))
	{
		return PTR_ERR(alinx_char.class);
	}

	/* 创建设备节点 */
	alinx_char.device = device_create(alinx_char.class, NULL,
			alinx_char.devid, NULL,
			DEVICE_NAME);
	if (IS_ERR(alinx_char.device))
	{
		return PTR_ERR(alinx_char.device);
	}

	return 0;
}

/* 卸载模块 */
static void __exit gpio_led_exit(void)
{
	/* 释放 gpio */
	gpio_free(alinx_char.alinx_led_gpio);

	/* 注销字符设备 */
	cdev_del(&alinx_char.cdev);

	/* 注销设备号 */
	unregister_chrdev_region(alinx_char.devid, DEVID_COUNT);

	/* 删除设备节点 */
	device_destroy(alinx_char.class, alinx_char.devid);


	/* 删除类 */
	class_destroy(alinx_char.class);

	printk("gpio_led_dev_exit_ok\n");
}

/* 标记加载、卸载函数 */
module_init(gpio_led_init);
module_exit(gpio_led_exit);

/* 驱动描述信息 */
MODULE_AUTHOR("Alinx");
MODULE_ALIAS("gpio_led");
MODULE_DESCRIPTION("PINCTRL AND GPIO LED driver");
MODULE_VERSION("v1.0");
MODULE_LICENSE("GPL");


</textarea>










<p>
内核定时器
</p> 
<textarea class="textarea-inherit" rows ="56";>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/ide.h>
#include <linux/types.h>
#include <linux/errno.h>
#include <linux/cdev.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <linux/semaphore.h>
#include <linux/timer.h>
#include <asm/uaccess.h>
#include <asm/io.h>

/* 设备节点名称 */
#define DEVICE_NAME "timer_led"
/* 设备号个数 */
#define DEVID_COUNT 1
/* 驱动个数 */
#define DRIVE_COUNT 1
/* 主设备号 */
#define MAJOR_U
/* 次设备号 */
#define MINOR_U 0


/* 把驱动代码中会用到的数据打包进设备结构体 */
struct alinx_char_dev{
	dev_t devid; //设备号
	struct cdev cdev; //字符设备
	struct class *class; //类
	struct device *device; //设备
	struct device_node *nd; //设备树的设备节点
	int alinx_led_gpio; //gpio 号
	char led_status; //gpio 状态
	unsigned int time_count; //定时器时间
	struct timer_list timer; //定时器
};
/* 声明设备结构体 */
static struct alinx_char_dev alinx_char = {
	.cdev = {
		.owner = THIS_MODULE,
	},
};

void timer_function(struct timer_list *timer)
{
	/* 反转 led 状态 */
	alinx_char.led_status = !alinx_char.led_status;
	/* 设置 led */
	gpio_set_value(alinx_char.alinx_led_gpio, alinx_char.led_status);
	/* 重新开始计时 */
	mod_timer(timer, jiffies + msecs_to_jiffies(alinx_char.time_count));
}

/* open 函数实现, 对应到 Linux 系统调用函数的 open 函数 */
static int timer_led_open(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module open\n");
	return 0;
}


/* write 函数实现, 对应到 Linux 系统调用函数的 write 函数 */
static ssize_t timer_led_write(struct file *file_p, const char __user *buf, size_t len, loff_t *loff_t_p)
{
	int retvalue;
	/* 获取用户数据 */
	retvalue = copy_from_user(&alinx_char.time_count, buf, len);
	/* 设置好 timer 后先点亮 led */
	alinx_char.led_status = 1;
	gpio_set_value(alinx_char.alinx_led_gpio, alinx_char.led_status);
	/* 开启 timer */
	mod_timer(&alinx_char.timer, jiffies + msecs_to_jiffies(alinx_char.time_count));

	return 0;
}

/* release 函数实现, 对应到 Linux 系统调用函数的 close 函数 */
static int timer_led_release(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module release\n");
	/* 删除定时器 */
	del_timer_sync(&alinx_char.timer);
	return 0;
}

/* file_operations 结构体声明, 是上面 open、write 实现函数与系统调用函数对应的关键 */
static struct file_operations ax_char_fops = {
	.owner = THIS_MODULE,
	.open = timer_led_open,
	.write = timer_led_write,
	.release = timer_led_release,
};

/* 模块加载时会调用的函数 */
static int __init timer_led_init(void)
{
	/* 用于接受返回值 */
	u32 ret = 0;

	/* 获取 led 设备节点 */
	alinx_char.nd = of_find_node_by_path("/alinxled");
	if(alinx_char.nd == NULL)
	{
		printk("alinx_char node not find\r\n");
		return -EINVAL;
	}
	else
	{
		printk("alinx_char node find\r\n");
	}

	/* 获取节点中 gpio 标号 */
	alinx_char.alinx_led_gpio = of_get_named_gpio(alinx_char.nd, "alinxled-gpios",
			0);
	if(alinx_char.alinx_led_gpio < 0)
	{
		printk("can not get alinxled-gpios");
		return -EINVAL;
	}
	printk("alinxled-gpio num = %d\r\n", alinx_char.alinx_led_gpio);

	/* 申请 gpio 标号对应的引脚 */
	ret = gpio_request(alinx_char.alinx_led_gpio, "alinxled");
	if(ret != 0)
	{
		printk("can not request gpio\r\n");
	}

	/* 把这个 io 设置为输出 */
	ret = gpio_direction_output(alinx_char.alinx_led_gpio, 1);
	if(ret < 0)
	{
		printk("can not set gpio\r\n");
	}

	/* 注册设备号 */
	alloc_chrdev_region(&alinx_char.devid, MINOR_U, DEVID_COUNT, DEVICE_NAME);

	/* 初始化字符设备结构体 */
	cdev_init(&alinx_char.cdev, &ax_char_fops);

	/* 注册字符设备 */
	cdev_add(&alinx_char.cdev, alinx_char.devid, DRIVE_COUNT);

	/* 创建类 */
	alinx_char.class = class_create(THIS_MODULE, DEVICE_NAME);
	if(IS_ERR(alinx_char.class))
	{
		return PTR_ERR(alinx_char.class);
	}

	/* 创建设备节点 */
	alinx_char.device = device_create(alinx_char.class, NULL,
			alinx_char.devid, NULL,
			DEVICE_NAME);
	if (IS_ERR(alinx_char.device))
	{
		return PTR_ERR(alinx_char.device);
	}

	/* 设置定时器回掉函数&初始化定时器 */
	timer_setup(&alinx_char.timer, timer_function, NULL);

	return 0;
}

/* 卸载模块 */
static void __exit timer_led_exit(void)
{
	/* 释放 gpio */
	gpio_free(alinx_char.alinx_led_gpio);

	/* 注销字符设备 */
	cdev_del(&alinx_char.cdev);

	/* 注销设备号 */
	unregister_chrdev_region(alinx_char.devid, DEVID_COUNT);

	/* 删除设备节点 */
	device_destroy(alinx_char.class, alinx_char.devid);

	/* 删除类 */
	class_destroy(alinx_char.class);

	printk("timer_led_dev_exit_ok\n");
}

/* 标记加载、卸载函数 */
module_init(timer_led_init);
module_exit(timer_led_exit);

/* 驱动描述信息 */
MODULE_AUTHOR("Alinx");
MODULE_ALIAS("gpio_led");
MODULE_DESCRIPTION("TIMER LED driver");
MODULE_VERSION("v1.0");
MODULE_LICENSE("GPL");


</textarea>


<p>
按键驱动
</p> 
<textarea class="textarea-inherit" rows ="56";>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/ide.h>
#include <linux/types.h>
#include <linux/errno.h>
#include <linux/cdev.h>

#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <linux/delay.h>
#include <asm/uaccess.h>
#include <linux/mtd/map.h>
#include <asm/io.h>

/* 设备节点名称 */
#define DEVICE_NAME "gpio_key"
/* 设备号个数 */
#define DEVID_COUNT 1
/* 驱动个数 */
#define DRIVE_COUNT 1
/* 主设备号 */
#define MAJOR1
/* 次设备号 */
#define MINOR1 0

/* 把驱动代码中会用到的数据打包进设备结构体 */
struct alinx_char_dev{
	dev_t devid; //设备号
	struct cdev cdev; //字符设备
	struct class *class; //类
	struct device *device; //设备
	struct device_node *nd; //设备树的设备节点
	int alinx_key_gpio; //gpio 号
};
/* 声明设备结构体 */
static struct alinx_char_dev alinx_char = {
	.cdev = {
		.owner = THIS_MODULE,
	},
};

/* open 函数实现, 对应到 Linux 系统调用函数的 open 函数 */
static int gpio_key_open(struct inode *inode_p, struct file *file_p)
{
	/* 设置私有数据 */
	file_p->private_data = &alinx_char;
	printk("gpio_test module open\n");
	return 0;
}


/* write 函数实现, 对应到 Linux 系统调用函数的 write 函数 */
static ssize_t gpio_key_read(struct file *file_p, char __user *buf, size_t len, loff_t *loff_t_p)
{
	int ret = 0;
	/* 返回按键的值 */
	unsigned int key_value = 0;
	/* 获取私有数据 */
	struct alinx_char_dev *dev = file_p->private_data;

	/* 检查按键是否被按下 */
	if(0 == gpio_get_value(dev->alinx_key_gpio))
	{
		/* 按键被按下 */
		/* 防抖 */
		mdelay(50);
		/* 等待按键抬起 */
		while(!gpio_get_value(dev->alinx_key_gpio));
		key_value = 1;
	}
	else
	{
		/* 按键未被按下 */
	}
	/* 返回按键状态 */
	ret = copy_to_user(buf, &key_value, sizeof(key_value));


	return ret;
}

/* release 函数实现, 对应到 Linux 系统调用函数的 close 函数 */
static int gpio_key_release(struct inode *inode_p, struct file *file_p)
{
	printk("gpio_test module release\n");
	return 0;
}

/* file_operations 结构体声明, 是上面 open、write 实现函数与系统调用函数对应的关键 */
static struct file_operations ax_char_fops = {
	.owner = THIS_MODULE,
	.open = gpio_key_open,
	.read = gpio_key_read,
	.release = gpio_key_release,
};

/* 模块加载时会调用的函数 */
static int __init gpio_key_init(void)
{
	/* 用于接受返回值 */
	u32 ret = 0;

	/* 获取设备节点 */
	alinx_char.nd = of_find_node_by_path("/alinxkey");
	if(alinx_char.nd == NULL)
	{
		printk("alinx_char node not find\r\n");
		return -EINVAL;
	}
	else
	{
		printk("alinx_char node find\r\n");
	}

	/* 获取节点中 gpio 标号 */
	alinx_char.alinx_key_gpio = of_get_named_gpio(alinx_char.nd, "alinxkey-gpios", 0);
	if(alinx_char.alinx_key_gpio < 0)
	{
		printk("can not get alinxkey-gpios");
		return -EINVAL;
	}
	printk("alinxkey-gpio num = %d\r\n", alinx_char.alinx_key_gpio);

	/* 申请 gpio 标号对应的引脚 */
	ret = gpio_request(alinx_char.alinx_key_gpio, "alinxkey");
	if(ret != 0)
	{
		printk("can not request gpio\r\n");
		return -EINVAL;
	}

	/* 把这个 io 设置为输入 */
	ret = gpio_direction_input(alinx_char.alinx_key_gpio);
	if(ret < 0)
	{
		printk("can not set gpio\r\n");
		return -EINVAL;
	}

	/* 注册设备号 */
	alloc_chrdev_region(&alinx_char.devid, MINOR1, DEVID_COUNT, DEVICE_NAME);

	/* 初始化字符设备结构体 */
	cdev_init(&alinx_char.cdev, &ax_char_fops);

	/* 注册字符设备 */
	cdev_add(&alinx_char.cdev, alinx_char.devid, DRIVE_COUNT);

	/* 创建类 */
	alinx_char.class = class_create(THIS_MODULE, DEVICE_NAME);
	if(IS_ERR(alinx_char.class))
	{
		return PTR_ERR(alinx_char.class);
	}

	/* 创建设备节点 */
	alinx_char.device = device_create(alinx_char.class, NULL,
			alinx_char.devid, NULL,
			DEVICE_NAME);
	if (IS_ERR(alinx_char.device))
	{
		return PTR_ERR(alinx_char.device);
	}

	return 0;
}

/* 卸载模块 */
static void __exit gpio_key_exit(void)
{
	/* 释放 gpio */
	gpio_free(alinx_char.alinx_key_gpio);

	/* 注销字符设备 */
	cdev_del(&alinx_char.cdev);

	/* 注销设备号 */
	unregister_chrdev_region(alinx_char.devid, DEVID_COUNT);

	/* 删除设备节点 */
	device_destroy(alinx_char.class, alinx_char.devid);

	/* 删除类 */
	class_destroy(alinx_char.class);

	printk("gpio_key_dev_exit_ok\n");
}

/* 标记加载、卸载函数 */
module_init(gpio_key_init);
module_exit(gpio_key_exit);

/* 驱动描述信息 */
MODULE_AUTHOR("Alinx");
MODULE_ALIAS("gpio_key");
MODULE_DESCRIPTION("GPIO OUT driver");
MODULE_VERSION("v1.0");
MODULE_LICENSE("GPL");




</textarea>


<p>
i2c
</p> 
<textarea class="textarea-inherit" rows ="56";>


</textarea>


<p>
i2c
</p> 
<textarea class="textarea-inherit" rows ="56";>


</textarea>


<p>
i2c
</p> 
<textarea class="textarea-inherit" rows ="56";>


</textarea>
</body>
</html>
</div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">zhoushenglin</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives"><div class="headline">Articles</div><div class="length_num">4</div></a></div></div><div class="card-info-bookmark is-center"><button class="button--animated" id="bookmark-it" type="button" title="Bookmark"><i class="fas fa-bookmark"></i><span>Bookmark</span></button></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhoushenglin" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zhoushenglin520@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">Hello!</div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-recent-item"><div class="aside-recent-post"><a href="/2022/08/19/WSL2petalinux/"><div class="aside-post-cover"><img class="aside-post-bg" data-src="/img/update.png" onerror="this.onerror=null;this.src='/img/404.jpg'" title="WSL下安装petalinux" alt="WSL下安装petalinux"/></div><div class="aside-post-title"><div class="aside-post_title" href="/2022/08/19/WSL2petalinux/" title="WSL下安装petalinux">WSL下安装petalinux</div><time class="aside-post_meta post-meta__date" title="Created 2022-08-19 09:40:42">2022-08-19</time></div></a></div><div class="aside-recent-post"><a href="/2020/08/14/video/"><div class="aside-post-cover"><img class="aside-post-bg" data-src="https://i.loli.net/2020/07/24/RMB739FgQeTSnhk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" title="video" alt="video"/></div><div class="aside-post-title"><div class="aside-post_title" href="/2020/08/14/video/" title="video">video</div><time class="aside-post_meta post-meta__date" title="Created 2020-08-14 10:51:21">2020-08-14</time></div></a></div><div class="aside-recent-post"><a href="/2020/08/10/hello-world/"><div class="aside-post-cover"><img class="aside-post-bg" data-src="https://i.loli.net/2020/07/24/RMB739FgQeTSnhk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" title="关于这个网站" alt="关于这个网站"/></div><div class="aside-post-title"><div class="aside-post_title" href="/2020/08/10/hello-world/" title="关于这个网站">关于这个网站</div><time class="aside-post_meta post-meta__date" title="Created 2020-08-10 22:05:27">2020-08-10</time></div></a></div><div class="aside-recent-post"><a href="/2020/08/10/update/"><div class="aside-post-cover"><img class="aside-post-bg" data-src="/img/update.png" onerror="this.onerror=null;this.src='/img/404.jpg'" title="更新记录" alt="更新记录"/></div><div class="aside-post-title"><div class="aside-post_title" href="/2020/08/10/update/" title="更新记录">更新记录</div><time class="aside-post_meta post-meta__date" title="Created 2020-08-10 16:26:16">2020-08-10</time></div></a></div></div></div></div><div class="card-widget card-archives"><div class="card-content"><div class="item-headline"><i class="fas fa-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">August 2022</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/08/"><span class="card-archive-list-date">August 2020</span><span class="card-archive-list-count">3</span></a></li></ul></div></div><div class="card-widget card-webinfo"><div class="card-content"><div class="item-headline"><i class="fas fa-chart-line"></i><span>Info</span></div><div class="webinfo"><div class="webinfo-item"><div class="webinfo-article-name">Article :</div><div class="webinfo-article-count">4</div></div><div class="webinfo-item">      <div class="webinfo-site-uv-name">UV :</div><div class="webinfo-site-uv-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="webinfo-site-name">PV :</div><div class="webinfo-site-pv-count" id="busuanzi_value_site_pv"></div></div></div></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By zhoushenglin</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">2</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>